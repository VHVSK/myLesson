REACT_APP_BASE_PATH=http://localhost:3000
REACT_APP_NOT_SECRET_CODE=MySecret/.8code.asdsa

# * Отже, як це працює:
# Під час розробки змінні беруться з файлу .env.local
# Під час продакшн версії змінні беруться з файлу .env.production.local

# * Файли дозволяють брати (приховувати, як вказати пусті значення в продакшн) змінні в залежності в процесу розробки
# https://create-react-app.dev/docs/adding-custom-environment-variables/
# ПОПЕРЕДЖЕННЯ: не зберігайте жодних секретів (наприклад, приватні ключі API) у своїй програмі React!

# Для vite інший підхід, дивіться тут: https://youtu.be/A-ls9OUqqy0 
# Також, в цьому відео описано, як GitHab надає можливість доступу до змінних на своему сервісі

# * Стоврити файл .env.local
# Додати в .gitignore, це бажано, але бувають випадки коли це не потрібно
# Змінні мають починатися з REACT_APP_, це в додатках які збирає create-react-app
# Ці змінні середовища будуть визначені для вас на process.env. Наприклад, змінна середовища з іменем REACT_APP_NOT_SECRET_CODE буде представлена ​​у вашому JS як process.env.REACT_APP_NOT_SECRET_CODE

# Існує також вбудована змінна середовища під назвою NODE_ENV. Ви можете прочитати це з process.env.NODE_ENV. Коли ви запускаєте npm start, він завжди дорівнює 'development', коли ви запускаєте, npm testвін завжди дорівнює 'test', а коли ви запускаєте, npm run buildщоб створити пакет виробництва, він завжди дорівнює 'production'. Ви не можете змінити NODE_ENVвручну. Це запобігає розробникам від випадкового розгортання збірки повільної розробки у виробництві. Ці змінні середовища можуть бути корисними для відображення інформації залежно від того, де розгорнуто проект або споживання конфіденційних даних, які знаходяться поза контролем версій.

# Доступ до NODE_ENV також корисний для умовного виконання дій: if (process.env.NODE_ENV !== 'production') { analytics.disable(); }  - Коли ви компілюєте програму за допомогою npm run buildкроку мініфікації, ця умова буде виключена, і кінцевий пакет буде меншим.

# * Які ще .env файли можна використовувати 
# Примітка: ця функція доступна з react-scripts@1.0.0і вище .

# .env: за замовчуванням.
# .env.local: локальні перевизначення. Цей файл завантажується для всіх середовищ, крім тестового.
# .env.development, .env.test, .env.production: налаштування для певного середовища.
# .env.development.local, .env.test.local, .env.production.local: локальні перевизначення налаштувань середовища.

# * Пріоритети...
# * Файли зліва мають більший пріоритет, ніж файли справа:
# npm start: .env.development.local, .env.local, .env.development,.env
# npm run build: .env.production.local, .env.local, .env.production,.env
# npm test: .env.test.local, .env.test, .env(примітка .env.localвідсутня)
# Ці змінні діятимуть як значення за замовчуванням, якщо машина не встановить їх явно.

# https://github.com/motdotla/dotenv 

# ! Введення даних із сервера на сторінку! !Увага, вразливість!
# https://create-react-app.dev/docs/title-and-meta-tags/#injecting-data-from-the-server-into-the-page

# Наприклад:

# <!doctype html>
# <html lang="en">
#   <head>
#     <script>
#       window.SERVER_DATA = __SERVER_DATA__;
#     </script>

# Потім на сервері ви можете замінити __SERVER_DATA__JSON реальних даних безпосередньо перед надсиланням відповіді. Потім код клієнта можна прочитати window.SERVER_DATA, щоб використовувати його. Обов’язково продезінфікуйте JSON, перш ніж надсилати його клієнту, оскільки це робить вашу програму вразливою до атак XSS.

# ! Обов’язково продезінфікуйте JSON:
# https://medium.com/node-security/the-most-common-xss-vulnerability-in-react-js-applications-2bdffbcc1fa0

# Найпоширеніша вразливість XSS у програмах React.js

#      <script>
#       window.__PRELOADER_STATE__ = ${JSON.stringify(preloaderState)};
#     </script>

# Проблема з цим фрагментом коду полягає в тому, як ми передаємо стан Store у програму. На наведеному вище знімку екрана ми просто виконуємо JSON.stringifyвиклик і призначаємо його глобальній змінній у тезі сценарію. Це вразливість.

# Коли веб-браузер аналізує HTML сторінки та зустрічає цей <script>тег, вони продовжуватимуть читати, доки не побачать </script>— це означає, що якщо ваше сховище redux має значення, подібне до наступного, тоді, коли ви завантажуєте клієнт, ви будете отримати сповіщення «У вас уразливість XSS!».

# {
#   user: {
#     username: "NodeSecurity",
#     bio: "as</script><script>alert('You have an XSS vulnerability!')</script>"
#   }
# }

# Браузер фактично не читатиме до останньої фігурної дужки, замість цього він фактично завершить тег сценарію після bio: "as

# ! Як можна запобігти цій уразливості XSS?
# На щастя, Open Web Application Security Project має великий вибір ресурсів про запобігання XSS . Щоб запобігти цій вразливості, нам потрібно вжити кількох заходів безпеки в наших програмах:

# Шпаргалка щодо запобігання міжсайтовим сценаріям:
# https://cheatsheetseries.owasp.org/cheatsheets/Cross_Site_Scripting_Prevention_Cheat_Sheet.html
# https://owasp.org/about/

# 1. Усі введені користувачем дані мають мати екрановані сутності HTML. Коли ви використовуєте React, він запобігає більшості вразливостей XSS завдяки тому, як він створює вузли DOM і текстовий вміст.
# 2. Під час серіалізації стану на сервері для надсилання клієнту вам потрібно серіалізувати таким чином, щоб уникнути сутностей HTML. Це відбувається тому, що ви часто більше не використовуєте React для створення цього рядка, отже, рядок не екранується автоматично.

# Інженери Yahoo, на щастя, зробили останню з цих практик безпеки дуже простою для впровадження через свій модуль Serialize JavaScript . Який ви можете легко закинути в будь-який додаток.
# https://github.com/yahoo/serialize-javascript

# ! serialize
# Спочатку встановіть модуль з:npm install --save serialize-javascript
# https://www.npmjs.com/package/serialize-javascript 
# Потім ми можемо змінити попередній фрагмент, щоб він виглядав так: Зокрема, зверніть увагу на зміну, де ми використовуємо serialize замість JSON.stringifyприсвоєння значення__PRELOADED_STATE__

#      <script>
#       window.__PRELOADER_STATE__ = ${serialize(preloaderState, {isJSON: true})};
#     </script>

# Що стосується отримання даних на стороні клієнта, це працює так само, як і раніше, за винятком того, що тепер у вас є лише екрановані сутності HTML у рядку (вони виглядатимуть: \\u003C\\u002Fscript\\u003E, а не як </script>)

# Пам’ятайте: саме тому, що ви створюєте програму з найновішими технологіями на ринку або технологіями, які використовує Facebook, ви все одно повинні подбати про всі стандартні методи безпеки, якби ви писали програму за допомогою Rails. , Django, PHP або старіший стек.  