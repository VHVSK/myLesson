import { createContext } from 'react'

// 1)
// const UserContext = createContext()

// 2)
// Часто передають в якості значення об'єкт
// const UserContext = createContext({
//   user: '',
//   setUser: () => {},
// })

// 3)
// Тут назви можуть бути інші
// але тоді в App потрібно змінити запис
// <UserContext.Provider value={{ userName: user, changeUserName: setUser }}>
// А також змінити в UserInfo замінити
const UserContext = createContext({
  userName: '',
  changeUserName: () => {},
})

export default UserContext

// 1
// UserContext - функція повертає об'єкт, який містить контекст
// ми зможемо змінювати цей контект та читати данні цього контексту.

// 2 - використання об'єкта, контекст у вигляді об'єкта
// Змінимо контекст таким чином, щоб в контексті в нас зберагався об'єкт.
// Створили об'єкт, додали user та setUser
// setUser в нас значення функція, setUser: () => {}, це для того, якщо десь відсутній провайдер, а ми пробуємо визвати setUser, то щоб в нас не з'явилася помилка. Такі операція являються признаком гарного тону при створені контекста.

// Далі, замість значення value={user}> в App.jsx нам потрібно передати об'єкт, напр:
// <UserContext.Provider value={{ user, setUser }}>
// Далі в файлі UserInfo.jsx в нас вже об'єкт:
// const user = useContext(UserContext), тому доступ до значення user.user
// Або виконати деструктуризацію: const {user} = useContext(UserContext)

// Ще раз, цей об'єкт, щоб не було помилки якщо немає провайдера
// {
//   userName: '',
//   changeUserName: () => {},
// }

// Також, це явно видно, що викоритовується, і вам і нішому розробнику

// Також, якщо змінюється контекст, то відбувається ререндеринг всього контексту
// Тому, при частому зміні контексту, і великі данні, то це може викликати затримки при ререндерингу, тому використовуйте дуже уважно!

// Ми це зробили!
// Дякую!
