/**
 * ! МОДУЛІ в JS
 * По суті, кожен файл JS це модулі.
 * Таким чином, кожен файл, це міні програма.
 * Наш код поділений на чатини, легше коригувати.
 * Організація коду.
 * Розділення відповідальності, кожна частина ізольован від інших частин і виконує свою певну задачу.
 * Легше підтримувати і додавати новий функціонал.
 * Легше додавати нові модулі та інтегрувати в проект.
 *
 * ! Характеристики модулів
 * - за умовчанням, жодна зі змінних не доступна в іншому модулі, вони ізольовані.
 * - щоб вона стала доступною, її потрібно експортувати.
 * - щоб її використавти, її потрібно імпортувати, імпортуйте тількі ті , які потрібні, не обов'язково всі.
 * - при імпорті її можна перейменувати.
 *
 * ! Варіанти модулів:
 * - CommonJS Modules (за умовчанням включені ці модулі) - використовують require ...
 * - ECMAScropt Modules (ESM) - використовують import ...
 *
 * CommonJS Modules - загальноприйнятий стандарт в node.js, в більшості використовують цей тип модулей. За умовчанням включені ці модулі.
 *
 * В нових проектах, частіше переходять на ECMAScropt Modules (ESM).
 *
 * ! Модулі CommonJS
 * * module.exports
 * - об'єкт для експортування з модуля, вказати зо хочено експортувати
 * * require()
 * - функція для імпорта з іншого модуля, вказати зо хочено імпортувати
 *
 * ! Об'єкт module.exports
 * .js - За умовчанням, любий файл з розширенням .js в node.ja являється CommonJS
 * module - це об'ект доступний в любому такому файлі.
 * module.exports - це об'ект, містить значення, які експортуються з модуля. За умовчанням він пустий, пустий об'єт і тому з нього за умовчанням нічого не екпортується.
 * exports - змінна, це копія module.exports
 * Так як це об'єкт, а об'єкт це посилающийся тип.
 *
 * ! Як влаштований модуль CommonJS
 * Цесь код в файлі поміщається в таку собі анонімну функцію (без назви),яка нам не видима:
 */
;(function (exports, require, module, __filename, __dirname) {
  // вміст модуля
})

// Так як це функція, тому в кодному файлі нам доступні такі змінні: exports, require, module, __filename, __dirname

// Перевірка анонімної функції, створити файл та визвати
console.log(arguments.callee) // function
console.log(arguments.callee.toString()) // ...code...
// А також:
// module, __filename, __dirname
console.log(module) // данні модуля, інформація модуля
console.log(__filename) // абсолютний шлях до цього файлу
console.log(__dirname) // абсолютний шлях до папки де знаходиться цей модуль, тобто файл

// exports
console.log(exports) // {}
console.log(module.exports) // {}
console.log(module.exports === exports) // true

// require
console.log(require)
// require це фунекція, а люба функція це об'єкт, тому їй були додані властивості...
// за допомогою require можна імпортувати змінні з інших модулей
// містить типи файлів, тому можна не вказувати розширення файлу при імпорті.

// ! Як експортувати функцію з модуля CommonJS
function printHello() {
  console.log('Hello World')
}

// Перший варіант, окремий запис
module.exports.printHello = printHello

// .printHello - додаванням ключа зі значення в об'єкт module.exports, .printHello може бути іншим, це ключ, наприклад .printHello_function, а значення це
// частіше всього назву фугнкції вказують однакові
// Щоб її визвати, її потрібно імпортувати в іншому модулі.

// Другий варірант запису:
module.exports.printHello = function () {
  console.log('Hello World')
}

// Для кращого читання використовуйте оремий варіант.
// Отже, щоб експортувати одну змінну то робіть так.

// ! Як переписати значення module.exports
// module.exports це об'єкт, якщо присвоїти функцію, то значення module.exports стає з об'єкта на функцію. Це допускається..., можна переписувати значення! В такому разі можна експортувати тільки одну змінну, а якщо використовувати як об'єкт, то можна експортувати декілька, з різним и назвами!!!
// Найчастіше мождулі одноцільові, вони експортують одне значення, одну змінну, тому такий варіант допускається!
module.exports = function () {
  console.log('Hello World')
}

// ! Аліас module.exports, exports - аліас
// В кожному модулі є дві змінні, головна module.exports та  аліас exports
// За умовчанням, вони посилаються на один і той самий об'єкт в пам'яті компютера.
// Ми можемо додати властивості або через змінну module.exports або через змінну exports, exports - короче...,
// тому можна писати і так:
exports.printHello = function () {
  console.log('Hello World')
}

// ! Присвоючати нове значення exports не можна!
// в такому випадку функція НЕ буде експортована, а також exports більше не буде посилатися на module.exports
exports = function () {
  console.log('Hello World')
}

// ! ІМПОРТ В МОДУЛЯХ
// ! Функція require
/**
 * 1. require - це функція, доступна в середині кожного CommonJS модуля
 * 2.  Функція require використовуються для імпорта змінних, які експортуються з інших модулей
 * 3. Можна імпортувати з вбудованих або зовнішніх модулей, вказавши ім'я модуля.
 * 4. Можна імпортувати з модулей додатка, вказавши шляж до певного модуля, зазвичай вказують відносні шляхи!
 *
 * ! Імпорт з вбудованих або зовнішніх модулей
 * Вказати тільки ім'я вбудованого або зовнішнього модуля, в даному випадку це - fs
 */

const fs = require('fs')

// Перед використанням зовнішніх модулей, їх потрібно встановити за допомогою:
// * npm install

// ! Імпорт ОДНОГО ЕКСПОРТА, єдиного!
// Наприклад в нас є файл:
// users.js
const users = ['Bogdan', 'Alice', 'Bob']

module.exports = users

// Щоб використати цю змінну в іншому файлі, напр.в:
// index.js
const usersArray = require('./users.js')

// ! Імпорт з модуля ДЕКІЛЬКІ ЗМІННИХ
// Наприклад в нас є файл в якому прописуємо константи:
// contacts.js
const URL = 'http://localhost'
const USERNAME = 'admin'
const PASSWORD = 'strong_pass'

module.exports.URL = URL
module.exports.USERNAME = USERNAME
module.exports.PASSWORD = PASSWORD

// Також, можна через exports, так як exports це аліас module.exports:
// exports.URL = URL
// exports.USERNAME = USERNAME
// exports.PASSWORD = PASSWORD

// Щоб використати ці змінні в іншому файлі, виконаємо деструктуризацію об'єкта, напр.в:
// index.js
const { URL, USERNAME, PASSWORD } = require('./contacts.js')
// Другий варіант, присвоїти вмінній, тобто буде об'єкт данних, тоді буде доступ зо зманної типу CONSTANS.URL
// * const CONSTANS = require('./contacts.js')
// Третій варіант, вибірковий:
// * const { URL } = require('./contacts.js')

// ! ІМПОРТ ФУНКЦІЙ
// Функція яка повертає данні з певрного url
// наприклад, маємо index.js
const getData = require('./utils')

getData('https://jsonplaceholder.typicode.com/posts')
  .then((posts) => console.log(posts))
  .catch((error) => console.log(error))

// and utils.js
async function getData(url) {
  const res = await fetch(url)
  const data = await res.json()
  return data
}

// В даному варінаті назва не обов'язкова
module.exports = getData
