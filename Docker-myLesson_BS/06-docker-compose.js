// ! До цього часу ми використовували ІМПЕРАТИВНИЙ ПІДХІД
// ! Існує ще ДЕКЛАРАТИВНИЙ ПІДХІД
// ! Рекоменджується викроистовувати саме цей ДЕКЛАРАТИВНИЙ ПІДХІД при розробці
// Тобто ми описуємо бажаний результат. Тобто за допомогою певних інструкція ми описуємо КІНЦЕВУ ціль.
// Це прописується в файлах типу docker-compose.yml (yaml)
// Приклад файлу: docker-compose.yml

version: '3'
services:
app:
    build: ./app
mongo:
    image: mongo

// Структура yaml файлу
// app: та mongo: - це назва сервісів
// Відступи мають значення!
// Списки та словарі (приклад вище)

// Списки, ключ fruits, список - ...
fruits:
    - banana
    - apple
    - orange

// Саме форрмат yaml вибраний для сервісів Docker Compose

// ! Коротко, для чього це?
// Запуск різних контейнерів використовуючи один сценарій, а не вручну кожен контейнер!

// ! Переваги Docker Compose
/**
 * - декларативний піждхід до створення контейнерів
 * - всі необхідні команди запускають однією командою
 * - автоматичні стоврення потрібних образів на основі Dockerfile
 * - створення багатоьох контейнерів використовується Docker Compose, Docker також створює окрему ізольовану мережу в середині Docker, і підключає всі створені контейнери до цієї мережі, окрема мережа дозволяє ізолювати їх від інших контейнерів які працюють на цьому Docker хості, при цьому ті які підключені в цій мереджі можуть між собою взаємодіяти.
 * - одне з важливих, завдяки DNS можна взаємодяти між контейнерами, використовуючи імена сервісів.
 */

/**
 * КОЖЕН КОНТЕЙНЕР НЕ ЗАЛЕЖИТЬ ВІД ІНШИХ
 * - часто потрібно в одному додатку, яке складається з багатьох сервісів, зробити так, щоб сервіли взаємодяли між собою, наприклад:
 * - фронтенд сервіс, який звертається до бекенду
 * - бекенд сервіс, який звертається до база даних
 * - база даних, і т.п.
 * 
 * І якщо викоритстовувати Docker Compose для створення таких сервісів, то можна побудувати взяємодіяти зв'язок між контейнерами, на сонові НАЗВ СЕРВІСІВ, і DNS в середині буде атоматично резолвити DNS імена сервісів до IP адресам відпорвідним контейннерам. IP адреса динамічні, а назви статичні.
 * 
 */

// ! ЗАПУСК ДВОХ СЕРВІСІВ ВИКОРИСТОВУЮЧИ Docker Compose
// Стоврили папку docker-compose-app та всі інші файли в цій папці.
// Запустити сам докер 
// Відкрили термінал та перейшли в цю папку
// * ls
// * docker-compose up
// ...
// app-1  - наш додаток
// docker-compose-app-app-1    | {'databases': [{'empty': False, 'name': 'admin', 'sizeOnDisk': 8192},
// docker-compose-app-app-1 exited with code 0
// * Ctrl + C - щоб зупинити, але не видалити
// Щоб видалити всі зупинені:
// * docker container prune

// ! Запусак в фоновому режимі (-d)
// * ls
// * docker-compose up -d
/**
 * [+] Running 2/2
 - Container docker-compose-app-app-1    S...                                      2.2s 
 - Container docker-compose-app-mongo-1  Started                                   2.2s
 */
// * docker ps -a

// ! Щоб зупинити та видалити всі контйенери як СТОСУЮТЬСЯ docker-compose
// * docker-compose down
// * docker ps -a
/**
 * ми бачимо, що зупений контйенер mongo, далі обидва контейнери були видалені, а також видалена ручна мережа ска стврювалася конкретно для них для взаємодії
 * 
 * - Container docker-compose-app-app-1    R...                                      0.0s 
 - Container docker-compose-app-mongo-1  Removed                                   0.5s 
 - Network docker-compose-app_default    R...                                      0.6s
 */

// ! Якщо ми внесли зміни в проект і нам потрібен перезапуск, ЗАПУСК ПІСЛЯ РЕДАГУВАННЯ ДОДАТКА
// Для цього є опція --build
// * docker-compose up -d --build 

// ! Дивимося логи
// Дастати код конетейнера
// * docker ps -a
// b8664aafdb95
// * docker logs b8664aafdb95
// маємо:
/**
 * {'databases': [{'empty': False, 'name': 'admin', 'sizeOnDisk': 8192},
               {'empty': False, 'name': 'config', 'sizeOnDisk': 12288},
               {'empty': False, 'name': 'local', 'sizeOnDisk': 8192}],
 'ok': 1.0,
 'totalSize': 28672,
 'totalSizeMb': 0}
End!!!!!!!!!!!!!!!!!!
 */
