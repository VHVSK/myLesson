// ! Етапи створення озразів
// 1. Для створення потрібний Dockerfile
// 2. Dockerfile розщмістити в корні файлу
// 3. Dockerfile містить в собі інструкції по створеню образа
// 4. При створені образа можна вказати Ім'я та Тег для образа
// 5. На основі такого образа можна створити контейнери

// ! Приклад Dockerfile, інструкції для створення образа
FROM python:alpine
WORKDIR /app 
COPY . .
CMD ["python", "main.py"]

// python:alpine - вказує який базовий образ буде використовуваттися, ім'я базового образа:тег (версія) базового образа (якщо без тегу, то буде використовуватися latest версія), alpine - це мінімальна версія, latest - сама актуальна
// WORKDIR /app - робоча директорія в середині образа, бажано вказувати, щоб не перезаписати систкмні файли
// COPY . . - копіювати з локальної поточної у внітрішню папку, в даному випадку це /app, на цьому етапі ми копіюємо сюда файл з нашого компютера.
// CMD ["python", "main.py"] - інструкція CMD, тобто команда яка вказує на те, яка команда буде виконана коли створиться новий контейнер на основі вже створеного образа, і нам потрібно запустити якийсь процес, в даному випадку запускатьтся процес python і він виконає файл main.py, а цей файл вже має бути в робочій директорії /app

// Після створення такого файлу, ми може створити образ виконавши команду 
// * docker build . 
// build - запуск процеса створення образа
// . поточна директорія до файлу Dockerfile

// Якщо в нас інше ім'я, а не Dockerfile, то вказати опцію:
// * -f falename_Dockerfile
// При створенні образа його ID буде випадковий, якщло ми хочемо задати певне ім'я, тег (опційно, тег можна не вказувати), то опція:
// * -t my-calendar:4.1.3
// При повторному створені з такою самою назвою, то образ перезаписується

// ! Тепер приступисо до стврення власного образу
// Створили папаку python-app
// Створили файл main.py
// Створили файл Dockerfile
// Відкрити термінал та перейти в цю папку
// Перевіримо які в нас є образи:
// * docker images
// Виконати:
// * docker build . -t my-calendar
// Перевіримо які в нас є образи:
// * docker images
// маємо:
// my-calendar   latest    d6e980fb9bf5   About a minute ago   56.8MB

// ! Створимо контейнер на основі цього образу:
// * docker run -it my-calendar

// ! Створимо нову версію нашого образу
// * docker build . -t my-calendar:2.0.0

// Перевіримо які в нас є образи:
// * docker images
// маємо:
// my-calendar   2.0.0     243939f0bd04   13 minutes ago   56.8MB

// ! Створимо контейнер на основі НОВОГО образу і ВЕРСІЇ:
// * docker run -it my-calendar:2.0.0

// Отже, створили та запустили!

// ! Аналіз файлової структури контейнера pyphon
// Запустимо процес, але не вводимо данні щоб процес був запущений:
// * docker run -it my-calendar:2.0.0
// Відкрити новий термінал
// * docker ps
// маємо запущений контейнер зі статусом Up
// беремо його код та запускаємо
// * docker exec -it ea8486d39803 sh
// І ми попали в оболочку /app #, зверніть увагу, ми автоматично попали в робочу директорію /app
// * ls
// * cat main.py
// * cd ..
// * ls
// маємо багато папок та файлів

// ! СТВОРИМО ДОДАТОК ДЛЯ Node
// create folder node-app
// create file index.mjs
// create file Dockerfile

// Відкрити термінал
// Перейти в папку node-app
// * docker build . -t my-file-write
// * docker images
// my-file-write   latest    f18d5fe1f9cd   About a minute ago   177MB
// * docker run -it my-file-write
// маємо:
// File created!

// Щоб зробити аналіз контейнера, можна модивікувати скрипт, наприклад додати settimeout
// setTimeout(() => console.log('End!'), 300000)

// Потім виконати запуск, потім дізнатися його ID, потім зайти в оболочку, потім прочитати список файлів, потім прочитати файл

// Відкрити новий термінал
// * docker ps
// маємо запущений контейнер зі статусом Up
// беремо його код та запускаємо
// * docker exec -it ea8486d39803 sh

